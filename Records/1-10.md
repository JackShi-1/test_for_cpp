#### 1. 两数之和
>给定一个整数数组 `nums` 和一个整数目标值`target`，请你在该数组中找出和为目标值`target`的那两个整数，并返回它们的数组下标。
```javascript
var twoSum = function(nums, target) {
    const hashNums = {};
    let result = [];
    nums.forEach((item,index)=>{
        const targetNum = target - item;
        if(hashNums[targetNum] === undefined ){
            hashNums[item] = index;
        }else{
            result =  [index,hashNums[targetNum]];
        }
    });
    return result;
};
```
```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int,int> hashNums;
        for(int i=0; i<nums.size();i++){
            auto item = hashNums.find(target-nums[i]);
            if(item != hashNums.end()){
                return {item->second,i};
            }
            hashNums[nums[i]]=i;
        }
        return {};
    }
};
```

#### 2. 两数相加
>给你两个**非空**的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。请你将两个数相加，并以相同形式返回一个表示和的链表。
```javascript
/**
 * Definition for singly-linked list.
 * function ListNode(val, next) {
 *     this.val = (val===undefined ? 0 : val)
 *     this.next = (next===undefined ? null : next)
 * }
 */
/**
 * @param {ListNode} l1
 * @param {ListNode} l2
 * @return {ListNode}
 */
var addTwoNumbers = function(l1, l2) {
    let initListNode = new ListNode('0');
    let theOne = 0;
    let answer = initListNode;
    while(theOne || l1 || l2){
        let val1 = l1?.val ?? 0;
        let val2 = l2?.val ?? 0;
        let addAll = theOne + val1 + val2;
        theOne = addAll >= 10 ? 1 : 0;
        initListNode.next = new ListNode(addAll % 10);
        initListNode = initListNode.next;
        l1 = l1 ? l1.next : l1;
        l2 = l2 ? l2.next : l2;
    }
    return answer.next;
};
```
```cpp
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode *head = nullptr, *tail = nullptr;
        int carry = 0;
        while(l1 || l2){
            int num1 = l1 ? l1->val : 0;
            int num2 = l2 ? l2->val : 0;
            int sum = num1 + num2 + carry;
            if(head){
                tail->next = new ListNode(sum % 10);
                tail = tail->next;
            }else{
                head = tail = new ListNode(sum % 10);
            }
            carry = sum / 10;
            l1 = l1 ? l1->next : nullptr;
            l2 = l2 ? l2->next : nullptr;
        }
        if(carry){
            tail->next = new ListNode(carry);
        }
        return head;
    }
};
```


#### 3. 无重复字符的最长子串 [滑动数组]
>给定一个字符串`s`，请你找出其中不含有重复字符的`最长子串`的长度。

需要使用一种数据结构来判断 **是否有重复的字符**，常用的数据结构为哈希集合（即 C++ 中的 `std::unordered_set`，Java 中的 `HashSet`，Python 中的 `set`, JavaScript 中的 `Set`）

依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！这里的原因在于，假设我们选择字符串中的第k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为rk。那么当我们选择第k+1个字符作为起始位置时，首先从k+1到rk+1的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大rk，直到右侧出现了重复字符为止。
```javascript
var lengthOfLongestSubstring = function(s) {
    let left = 0;
    let ans = 0;
    const hashSet = new Set();
    for(let i=0;i<s.length; i++){
        while(hashSet.has(s[i])){
            hashSet.delete(s[left]);
            left++;
        }
        ans = Math.max(ans,i-left+1);
        hashSet.add(s[i]);
    }
    return ans;
};
```
```cpp
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        int len = s.size();
        int left = 0;
        int ans = 0;
        unordered_set<char> hashSet;
        for(int i=0; i<len; i++){
            while(hashSet.find(s[i])!=hashSet.end()){
                hashSet.erase(s[left]);
                left++;
            }
            ans = max(ans,i-left+1);
            hashSet.insert(s[i]);
        }
        return ans;
    }
};
```
