Cç«¯å‰ç«¯æ€§èƒ½é—®é¢˜ä¸»è¦å½±å“ç”¨æˆ·ä½“éªŒå’Œè½¬åŒ–ç‡ï¼Œä»¥ä¸‹æ˜¯å¸¸è§é—®é¢˜åŠä¼˜åŒ–æ–¹å‘ï¼š

## ğŸ” å¸¸è§æ€§èƒ½é—®é¢˜

### 1. **åŠ è½½æ€§èƒ½é—®é¢˜**
- **é¦–å±åŠ è½½æ…¢**ï¼šç™½å±æ—¶é—´é•¿ï¼Œç”¨æˆ·ç­‰å¾…ç„¦è™‘
- **èµ„æºä½“ç§¯è¿‡å¤§**ï¼šJS/CSS/å›¾ç‰‡æœªä¼˜åŒ–
- **ç½‘ç»œè¯·æ±‚è¿‡å¤š**ï¼šæœªåˆå¹¶è¯·æ±‚ï¼ŒHTTP/1.1ä¸‹é˜Ÿå¤´é˜»å¡

### 2. **è¿è¡Œæ—¶æ€§èƒ½é—®é¢˜**
- **é¡µé¢å¡é¡¿**ï¼šé¢‘ç¹é‡æ’é‡ç»˜ï¼ŒJSæ‰§è¡Œæ—¶é—´è¿‡é•¿
- **å†…å­˜æ³„æ¼**ï¼šäº‹ä»¶ç›‘å¬æœªæ¸…é™¤ï¼ŒDOMå¼•ç”¨æœªé‡Šæ”¾
- **åŠ¨ç”»æ€§èƒ½å·®**ï¼šæœªä½¿ç”¨transform/opacityï¼Œå¼ºåˆ¶åŒæ­¥å¸ƒå±€

### 3. **äº¤äº’ä½“éªŒé—®é¢˜**
- **è¾“å…¥å“åº”å»¶è¿Ÿ**ï¼šé¢‘ç¹è§¦å‘å›è°ƒï¼ˆå¦‚æœç´¢è¾“å…¥ï¼‰
- **æ»šåŠ¨å¡é¡¿**ï¼šå¤æ‚å¸ƒå±€ï¼Œå¤§é‡ç›‘å¬å™¨
- **é•¿åˆ—è¡¨æ¸²æŸ“æ…¢**ï¼šæœªè™šæ‹ŸåŒ–ï¼ŒDOMèŠ‚ç‚¹è¿‡å¤š

## ğŸš€ æ ¸å¿ƒä¼˜åŒ–æ–¹å‘

### 1. **åŠ è½½ä¼˜åŒ–**
```javascript
// ç­–ç•¥ç¤ºä¾‹
const strategies = {
  1: 'ä»£ç åˆ†å‰² + æ‡’åŠ è½½',
  2: 'èµ„æºå‹ç¼© + å›¾ç‰‡ä¼˜åŒ–',
  3: 'CDNåŠ é€Ÿ + ç¼“å­˜ç­–ç•¥',
  4: 'é¢„åŠ è½½/é¢„è¿æ¥å…³é”®èµ„æº'
}
```
- **å‡å°‘å…³é”®èµ„æº**ï¼šç§»é™¤éå¿…è¦ç¬¬ä¸‰æ–¹åº“
- **ä¼˜åŒ–æ‰“åŒ…ç­–ç•¥**ï¼šTree-shakingï¼ŒæŒ‰éœ€åŠ è½½
- **ä½¿ç”¨ç°ä»£æ ¼å¼**ï¼šWebPå›¾ç‰‡ï¼ŒES6+æ¨¡å—

### 2. **æ¸²æŸ“ä¼˜åŒ–**
```javascript
// ä¼˜åŒ–ç¤ºä¾‹
function optimizeRendering() {
  // ä½¿ç”¨è™šæ‹Ÿåˆ—è¡¨
  // é˜²æŠ–/èŠ‚æµè¾“å…¥äº‹ä»¶
  // ä½¿ç”¨Web Workerå¤„ç†è®¡ç®—
  // é¿å…å¼ºåˆ¶åŒæ­¥å¸ƒå±€
}
```
- **å‡å°‘é‡æ’é‡ç»˜**ï¼šæ‰¹é‡DOMæ“ä½œ
- **ä½¿ç”¨CSSç¡¬ä»¶åŠ é€Ÿ**ï¼štransformä»£æ›¿top/left
- **ä¼˜åŒ–äº‹ä»¶å¤„ç†**ï¼šäº‹ä»¶å§”æ‰˜ï¼Œåˆç†èŠ‚æµ

### 3. **ç¼“å­˜ç­–ç•¥**
- **åˆç†è®¾ç½®ç¼“å­˜å¤´**ï¼šmax-age, ETag
- **Service Worker**ï¼šç¦»çº¿ä½“éªŒï¼Œèµ„æºç¼“å­˜
- **æœ¬åœ°å­˜å‚¨**ï¼šIndexedDBå­˜å‚¨å¤§é‡æ•°æ®

### 4. **ç½‘ç»œä¼˜åŒ–**
- **HTTP/2æˆ–HTTP/3**ï¼šå¤šè·¯å¤ç”¨ï¼Œå¤´éƒ¨å‹ç¼©
- **èµ„æºé¢„åŠ è½½**ï¼š`<link rel="preload">`
- **è¿æ¥é¢„çƒ­**ï¼š`<link rel="preconnect">`

## ğŸ“Š æ€§èƒ½ç›‘æ§ä½“ç³»

### 1. **æ ¸å¿ƒæŒ‡æ ‡ï¼ˆWeb Vitalsï¼‰**
- **LCP**ï¼ˆæœ€å¤§å†…å®¹ç»˜åˆ¶ï¼‰ï¼š< 2.5s
- **FID**ï¼ˆé¦–æ¬¡è¾“å…¥å»¶è¿Ÿï¼‰ï¼š< 100ms  
- **CLS**ï¼ˆç´¯ç§¯å¸ƒå±€åç§»ï¼‰ï¼š< 0.1

### 2. **ç›‘æ§å·¥å…·**
```javascript
// ä½¿ç”¨Performance API
const perfData = {
  navigation: performance.getEntriesByType('navigation'),
  paint: performance.getEntriesByType('paint'),
  measure: performance.measure('custom-metric')
}
```

### 3. **çœŸå®ç”¨æˆ·ç›‘æ§ï¼ˆRUMï¼‰**
- é”™è¯¯ç‡ç›‘æ§
- ç”¨æˆ·è¡Œä¸ºå…³è”åˆ†æ
- åœ°ç†/è®¾å¤‡ç»´åº¦åˆ†æ

## ğŸ› ï¸ ç°ä»£ä¼˜åŒ–æŠ€æœ¯

### 1. **æ¡†æ¶çº§ä¼˜åŒ–**
- **React**ï¼šSuspenseæ‡’åŠ è½½ï¼ŒuseMemoç¼“å­˜
- **Vue**ï¼šå¼‚æ­¥ç»„ä»¶ï¼Œv-onceé™æ€åŒ–
- **Svelte**ï¼šç¼–è¯‘æ—¶ä¼˜åŒ–ï¼Œè¿è¡Œæ—¶è½»é‡

### 2. **æ„å»ºå·¥å…·ä¼˜åŒ–**
```javascript
// vite.config.js ç¤ºä¾‹
export default {
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom']
        }
      }
    }
  }
}
```

### 3. **é«˜çº§æŠ€æœ¯**
- **WebAssembly**ï¼šè®¡ç®—å¯†é›†å‹ä»»åŠ¡
- **Web Workers**ï¼šåå°å¤„ç†
- **Partial Hydration**ï¼šæ¸è¿›å¼æ³¨æ°´

## ğŸ“ˆ ä¼˜åŒ–ä¼˜å…ˆçº§å»ºè®®

1. **ç´§æ€¥å¤„ç†**ï¼ˆå½±å“è½¬åŒ–ç‡ï¼‰
   - å…³é”®è·¯å¾„èµ„æºä¼˜åŒ–
   - é¦–å±åŠ è½½æ—¶é—´
   - äº¤äº’å“åº”é€Ÿåº¦

2. **ä¸­æœŸä¼˜åŒ–**
   - ä»£ç æ¶æ„é‡æ„
   - ç¼“å­˜ç­–ç•¥å®Œå–„
   - ç›‘æ§ä½“ç³»å»ºç«‹

3. **é•¿æœŸç»´æŠ¤**
   - æ€§èƒ½æ–‡åŒ–å»ºç«‹
   - è‡ªåŠ¨åŒ–æ€§èƒ½æµ‹è¯•
   - æŒç»­ç›‘æ§ä¼˜åŒ–

## ğŸ”§ å®ç”¨å·¥å…·æ¨è
- **åˆ†æå·¥å…·**ï¼šLighthouse, WebPageTest
- **ç›‘æ§å¹³å°**ï¼šSentry, Performance API
- **æ„å»ºå·¥å…·**ï¼šVite, Webpack-bundle-analyzer

**å…³é”®å»ºè®®**ï¼šæ€§èƒ½ä¼˜åŒ–æ˜¯æŒç»­è¿‡ç¨‹ï¼Œå»ºè®®å»ºç«‹æ€§èƒ½é¢„ç®—ï¼ˆå¦‚æ€»JS<200KBï¼‰ï¼Œåœ¨æ¯æ¬¡è¿­ä»£ä¸­ç›‘æ§å¹¶ä¼˜åŒ–ï¼Œé‡ç‚¹å…³æ³¨çœŸå®ç”¨æˆ·çš„æ ¸å¿ƒä½“éªŒæŒ‡æ ‡ã€‚



# Cç«¯å‰ç«¯æ€§èƒ½ä¼˜åŒ–å…·ä½“æ–¹æ¡ˆ

## ğŸ“¦ **åŠ è½½ä¼˜åŒ–å…·ä½“æ–¹æ¡ˆ**

### 1. **ä»£ç åˆ†å‰²ä¸æ‡’åŠ è½½**
```javascript
// React è·¯ç”±æ‡’åŠ è½½
const Home = React.lazy(() => import('./Home'));
const About = React.lazy(() => import('./About'));

// ç»„ä»¶çº§æ‡’åŠ è½½ + åŠ è½½çŠ¶æ€
const ProductList = React.lazy(() => 
  import('./ProductList').then(module => ({
    default: module.ProductList
  }))
);

// å›¾ç‰‡æ‡’åŠ è½½ï¼ˆIntersectionObserverï¼‰
const lazyLoadImage = (img) => {
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        img.src = img.dataset.src;
        observer.unobserve(img);
      }
    });
  });
  observer.observe(img);
};
```

### 2. **Webpack/Vite æ‰“åŒ…ä¼˜åŒ–é…ç½®**
```javascript
// vite.config.js å…·ä½“é…ç½®
export default {
  build: {
    rollupOptions: {
      output: {
        // æ‰‹åŠ¨æ‹†åŒ…ç­–ç•¥
        manualChunks: (id) => {
          if (id.includes('node_modules')) {
            if (id.includes('lodash')) return 'vendor-lodash';
            if (id.includes('moment')) return 'vendor-moment';
            if (id.includes('antd') || id.includes('element-ui')) return 'vendor-ui';
            if (id.includes('react') || id.includes('vue')) return 'vendor-framework';
            return 'vendor';
          }
        },
        // æ–‡ä»¶åå“ˆå¸Œç­–ç•¥
        entryFileNames: 'assets/[name].[hash:8].js',
        chunkFileNames: 'assets/[name].[hash:8].chunk.js',
        assetFileNames: 'assets/[name].[hash:8].[ext]'
      }
    },
    // å‹ç¼©é…ç½®
    terserOptions: {
      compress: {
        drop_console: true,
        drop_debugger: true,
        pure_funcs: ['console.log']
      }
    },
    // äº§ç‰©åˆ†æ
    reportCompressedSize: false
  },
  // ä¾èµ–é¢„æ„å»º
  optimizeDeps: {
    include: ['lodash-es', 'axios']
  }
};
```

### 3. **å›¾ç‰‡ä¼˜åŒ–å…·ä½“æ–¹æ¡ˆ**
```javascript
// å›¾ç‰‡ç»„ä»¶å°è£…
const OptimizedImage = ({ src, alt, width, height }) => {
  const [imageSrc, setImageSrc] = useState('/placeholder.jpg');
  
  useEffect(() => {
    const img = new Image();
    img.src = src;
    img.onload = () => setImageSrc(src);
    
    // WebP æ ¼å¼æ£€æµ‹
    const checkWebP = () => {
      const webPSrc = src.replace(/\.(jpg|png)$/, '.webp');
      const testImg = new Image();
      testImg.onload = () => setImageSrc(webPSrc);
      testImg.src = webPSrc;
    };
    checkWebP();
  }, [src]);

  return (
    <img 
      src={imageSrc} 
      alt={alt}
      width={width}
      height={height}
      loading="lazy"
      decoding="async"
    />
  );
};

// å›¾ç‰‡å‹ç¼©å·¥å…·å‡½æ•°
const compressImage = async (file, maxWidth = 1920, quality = 0.8) => {
  return new Promise((resolve) => {
    const reader = new FileReader();
    reader.readAsDataURL(file);
    reader.onload = (e) => {
      const img = new Image();
      img.src = e.target.result;
      img.onload = () => {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        
        let width = img.width;
        let height = img.height;
        
        if (width > maxWidth) {
          height = (maxWidth / width) * height;
          width = maxWidth;
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        canvas.toBlob(
          (blob) => resolve(blob),
          'image/jpeg',
          quality
        );
      };
    };
  });
};
```

## âš¡ **è¿è¡Œæ—¶ä¼˜åŒ–æ–¹æ¡ˆ**

### 1. **è™šæ‹Ÿåˆ—è¡¨å®ç°ï¼ˆé•¿åˆ—è¡¨ä¼˜åŒ–ï¼‰**
```javascript
// è™šæ‹Ÿåˆ—è¡¨ç»„ä»¶
const VirtualList = ({ items, itemHeight, renderItem, containerHeight, overscan = 5 }) => {
  const [scrollTop, setScrollTop] = useState(0);
  const containerRef = useRef();
  
  const totalHeight = items.length * itemHeight;
  const startIndex = Math.floor(scrollTop / itemHeight);
  const visibleCount = Math.ceil(containerHeight / itemHeight);
  const endIndex = Math.min(startIndex + visibleCount + overscan, items.length);
  
  const visibleItems = items.slice(startIndex, endIndex);
  const offsetY = startIndex * itemHeight;
  
  const handleScroll = useCallback(() => {
    if (containerRef.current) {
      setScrollTop(containerRef.current.scrollTop);
    }
  }, []);
  
  useEffect(() => {
    const container = containerRef.current;
    if (container) {
      container.addEventListener('scroll', handleScroll, { passive: true });
      return () => container.removeEventListener('scroll', handleScroll);
    }
  }, [handleScroll]);
  
  return (
    <div 
      ref={containerRef}
      style={{ height: containerHeight, overflowY: 'auto' }}
    >
      <div style={{ height: totalHeight, position: 'relative' }}>
        <div style={{ transform: `translateY(${offsetY}px)` }}>
          {visibleItems.map((item, index) => (
            <div 
              key={item.id}
              style={{ height: itemHeight, position: 'absolute', top: 0 }}
            >
              {renderItem(item, startIndex + index)}
            </div>
          ))}
        </div>
      </div>
    </div>
  );
};

// ä½¿ç”¨ç¤ºä¾‹
const LongList = () => {
  const items = Array.from({ length: 10000 }, (_, i) => ({
    id: i,
    text: `Item ${i}`
  }));
  
  return (
    <VirtualList
      items={items}
      itemHeight={50}
      containerHeight={500}
      renderItem={(item) => (
        <div style={{ padding: '10px', borderBottom: '1px solid #eee' }}>
          {item.text}
        </div>
      )}
    />
  );
};
```

### 2. **Web Worker ä¼˜åŒ–è®¡ç®—**
```javascript
// worker.js
self.onmessage = function(e) {
  const { data, type } = e.data;
  
  switch(type) {
    case 'FILTER_DATA':
      // å¤§æ•°æ®è¿‡æ»¤
      const result = data.filter(item => 
        item.name.toLowerCase().includes(e.data.query.toLowerCase())
      );
      self.postMessage({ type: 'FILTER_RESULT', result });
      break;
      
    case 'SORT_DATA':
      // å¤æ‚æ’åº
      const sorted = [...data].sort((a, b) => {
        // å¤æ‚æ’åºé€»è¾‘
        return new Date(b.date) - new Date(a.date);
      });
      self.postMessage({ type: 'SORT_RESULT', sorted });
      break;
      
    case 'CALCULATE_STATS':
      // ç»Ÿè®¡è®¡ç®—
      const stats = {
        average: data.reduce((a, b) => a + b.value, 0) / data.length,
        max: Math.max(...data.map(d => d.value)),
        min: Math.min(...data.map(d => d.value))
      };
      self.postMessage({ type: 'STATS_RESULT', stats });
      break;
  }
};

// ä¸»çº¿ç¨‹ä½¿ç”¨
const useWebWorker = () => {
  const workerRef = useRef();
  
  useEffect(() => {
    workerRef.current = new Worker('worker.js');
    
    return () => {
      workerRef.current.terminate();
    };
  }, []);
  
  const processData = useCallback((data, type) => {
    return new Promise((resolve) => {
      workerRef.current.postMessage({ data, type });
      workerRef.current.onmessage = (e) => {
        resolve(e.data);
      };
    });
  }, []);
  
  return { processData };
};
```

### 3. **å†…å­˜æ³„æ¼æ£€æµ‹ä¸ä¿®å¤**
```javascript
// å†…å­˜æ³„æ¼æ£€æµ‹å·¥å…·
class MemoryLeakDetector {
  constructor() {
    this.references = new WeakMap();
    this.interval = null;
  }
  
  track(component, dependencies = []) {
    const refs = {
      timestamp: Date.now(),
      dependencies,
      component: component.constructor.name
    };
    this.references.set(component, refs);
  }
  
  startMonitoring(interval = 60000) {
    this.interval = setInterval(() => {
      this.checkLeaks();
    }, interval);
  }
  
  checkLeaks() {
    const now = Date.now();
    let leakCount = 0;
    
    // å¯ä»¥æ·»åŠ æ›´å¤šæ£€æµ‹é€»è¾‘
    console.log('Memory check at:', new Date().toISOString());
    
    return leakCount;
  }
  
  cleanup() {
    if (this.interval) {
      clearInterval(this.interval);
    }
  }
}

// React ä½¿ç”¨ç¤ºä¾‹
const useLeakDetection = (componentName) => {
  const detector = useRef(new MemoryLeakDetector());
  
  useEffect(() => {
    detector.current.track({ name: componentName });
    
    return () => {
      // æ¸…ç†å·¥ä½œ
      detector.current.cleanup();
    };
  }, [componentName]);
};

// å¸¸è§å†…å­˜æ³„æ¼ä¿®å¤
const SafeComponent = () => {
  const [data, setData] = useState([]);
  
  useEffect(() => {
    let mounted = true;
    
    const fetchData = async () => {
      try {
        const result = await api.getData();
        if (mounted) {
          setData(result);
        }
      } catch (error) {
        if (mounted) {
          console.error('Error:', error);
        }
      }
    };
    
    fetchData();
    
    return () => {
      mounted = false; // é˜²æ­¢ setState åœ¨å¸è½½åæ‰§è¡Œ
    };
  }, []);
  
  // äº‹ä»¶ç›‘å¬æ¸…ç†
  useEffect(() => {
    const handleResize = () => {
      // å¤„ç† resize
    };
    
    window.addEventListener('resize', handleResize, { passive: true });
    
    return () => {
      window.removeEventListener('resize', handleResize);
    };
  }, []);
  
  return <div>{data.length} items</div>;
};
```

## ğŸ¯ **äº¤äº’ä¼˜åŒ–æ–¹æ¡ˆ**

### 1. **é˜²æŠ–èŠ‚æµä¼˜åŒ–è¾“å…¥**
```javascript
// é«˜çº§é˜²æŠ–èŠ‚æµ Hook
const useOptimizedCallback = (callback, delay, options = {}) => {
  const {
    leading = false,
    trailing = true,
    maxWait
  } = options;
  
  const callbackRef = useRef(callback);
  const timeoutRef = useRef();
  const lastCallRef = useRef();
  const lastInvokeRef = useRef(0);
  
  useEffect(() => {
    callbackRef.current = callback;
  }, [callback]);
  
  const debounced = useCallback((...args) => {
    const now = Date.now();
    
    if (leading && !timeoutRef.current) {
      lastInvokeRef.current = now;
      callbackRef.current(...args);
    }
    
    if (lastCallRef.current && now - lastCallRef.current < delay) {
      clearTimeout(timeoutRef.current);
    }
    
    lastCallRef.current = now;
    
    timeoutRef.current = setTimeout(() => {
      if (trailing && (now - lastInvokeRef.current >= delay)) {
        lastInvokeRef.current = now;
        callbackRef.current(...args);
      }
      timeoutRef.current = null;
    }, delay);
    
    if (maxWait && !timeoutRef.current) {
      timeoutRef.current = setTimeout(() => {
        lastInvokeRef.current = now;
        callbackRef.current(...args);
        timeoutRef.current = null;
      }, maxWait);
    }
  }, [delay, leading, trailing, maxWait]);
  
  useEffect(() => {
    return () => {
      if (timeoutRef.current) {
        clearTimeout(timeoutRef.current);
      }
    };
  }, []);
  
  return debounced;
};

// æœç´¢è¾“å…¥ä¼˜åŒ–ç¤ºä¾‹
const OptimizedSearch = () => {
  const [query, setQuery] = useState('');
  const [results, setResults] = useState([]);
  const [loading, setLoading] = useState(false);
  
  const searchAPI = async (searchQuery) => {
    if (!searchQuery.trim()) return;
    
    setLoading(true);
    try {
      const response = await fetch(`/api/search?q=${encodeURIComponent(searchQuery)}`);
      const data = await response.json();
      setResults(data);
    } catch (error) {
      console.error('Search error:', error);
    } finally {
      setLoading(false);
    }
  };
  
  // é˜²æŠ–æœç´¢ï¼Œ300mså»¶è¿Ÿï¼Œå…è®¸ç«‹å³æ‰§è¡Œç¬¬ä¸€æ¬¡
  const debouncedSearch = useOptimizedCallback(searchAPI, 300, {
    leading: true,
    trailing: true
  });
  
  const handleInputChange = (e) => {
    const value = e.target.value;
    setQuery(value);
    debouncedSearch(value);
  };
  
  return (
    <div>
      <input
        type="text"
        value={query}
        onChange={handleInputChange}
        placeholder="Search..."
      />
      {loading && <div>Loading...</div>}
      <ul>
        {results.map((result) => (
          <li key={result.id}>{result.name}</li>
        ))}
      </ul>
    </div>
  );
};
```

### 2. **åŠ¨ç”»æ€§èƒ½ä¼˜åŒ–**
```javascript
// é«˜æ€§èƒ½åŠ¨ç”»ç»„ä»¶
const HardwareAcceleratedAnimation = () => {
  const [progress, setProgress] = useState(0);
  const animationRef = useRef();
  
  useEffect(() => {
    const animate = (timestamp) => {
      // ä½¿ç”¨ requestAnimationFrame
      const newProgress = (timestamp % 2000) / 2000;
      setProgress(newProgress);
      
      animationRef.current = requestAnimationFrame(animate);
    };
    
    animationRef.current = requestAnimationFrame(animate);
    
    return () => {
      if (animationRef.current) {
        cancelAnimationFrame(animationRef.current);
      }
    };
  }, []);
  
  return (
    <div style={{
      position: 'relative',
      width: '300px',
      height: '20px',
      backgroundColor: '#eee',
      borderRadius: '10px',
      overflow: 'hidden'
    }}>
      {/* ä½¿ç”¨ transform è€Œé left/top */}
      <div style={{
        position: 'absolute',
        top: 0,
        left: 0,
        width: '100%',
        height: '100%',
        backgroundColor: '#007bff',
        // GPUåŠ é€Ÿ
        transform: `translateX(${(progress - 1) * 100}%)`,
        // å¯ç”¨GPUåŠ é€Ÿ
        willChange: 'transform',
        // å¹³æ»‘åŠ¨ç”»
        transition: progress > 0 ? 'transform 0.1s linear' : 'none'
      }} />
    </div>
  );
};

// CSS åŠ¨ç”»ä¼˜åŒ–ç¤ºä¾‹
const OptimizedCSSAnimation = () => (
  <style>{`
    .optimized-animation {
      /* åªè§¦å‘åˆæˆå±‚ï¼Œä¸è§¦å‘é‡æ’é‡ç»˜ */
      animation: slide 1s ease-in-out;
      /* ç¡¬ä»¶åŠ é€Ÿ */
      transform: translateZ(0);
      /* åˆ›å»ºç‹¬ç«‹å›¾å±‚ */
      isolation: isolate;
    }
    
    @keyframes slide {
      from {
        transform: translateX(-100%) translateZ(0);
      }
      to {
        transform: translateX(0) translateZ(0);
      }
    }
    
    /* ä¼˜åŒ–æ»šåŠ¨ */
    .smooth-scroll {
      scroll-behavior: smooth;
      /* å¯ç”¨ç¡¬ä»¶åŠ é€Ÿæ»šåŠ¨ */
      -webkit-overflow-scrolling: touch;
    }
  `}</style>
);
```

## ğŸ—„ï¸ **ç¼“å­˜ç­–ç•¥å…·ä½“å®ç°**

### 1. **Service Worker ç¼“å­˜ç­–ç•¥**
```javascript
// service-worker.js
const CACHE_NAME = 'v1';
const ASSETS_TO_CACHE = [
  '/',
  '/index.html',
  '/main.bundle.js',
  '/style.css',
  '/favicon.ico'
];

// å®‰è£…æ—¶ç¼“å­˜èµ„æº
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(ASSETS_TO_CACHE))
      .then(() => self.skipWaiting())
  );
});

// æ¿€æ´»æ—¶æ¸…ç†æ—§ç¼“å­˜
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    }).then(() => self.clients.claim())
  );
});

// ç½‘ç»œè¯·æ±‚æ‹¦æˆª
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => {
        // ç¼“å­˜ä¼˜å…ˆç­–ç•¥
        if (response) {
          return response;
        }
        
        // ç½‘ç»œè¯·æ±‚
        return fetch(event.request)
          .then(response => {
            // åªç¼“å­˜æˆåŠŸå“åº”
            if (!response || response.status !== 200) {
              return response;
            }
            
            // å…‹éš†å“åº”ä»¥ç¼“å­˜
            const responseToCache = response.clone();
            caches.open(CACHE_NAME)
              .then(cache => {
                cache.put(event.request, responseToCache);
              });
            
            return response;
          })
          .catch(() => {
            // ç½‘ç»œå¤±è´¥æ—¶è¿”å›å…œåº•
            if (event.request.headers.get('accept').includes('text/html')) {
              return caches.match('/offline.html');
            }
          });
      })
  );
});
```

### 2. **IndexedDB ç¼“å­˜å¤§é‡æ•°æ®**
```javascript
// IndexedDB å·¥å…·ç±»
class IndexedDBCache {
  constructor(dbName, version = 1) {
    this.dbName = dbName;
    this.version = version;
    this.db = null;
  }
  
  async init(stores) {
    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, this.version);
      
      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve(this.db);
      };
      
      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        
        stores.forEach(store => {
          if (!db.objectStoreNames.contains(store.name)) {
            const objectStore = db.createObjectStore(store.name, {
              keyPath: store.keyPath || 'id'
            });
            
            // åˆ›å»ºç´¢å¼•
            if (store.indexes) {
              store.indexes.forEach(index => {
                objectStore.createIndex(index.name, index.keyPath, index.options);
              });
            }
          }
        });
      };
    });
  }
  
  async add(storeName, data) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.add(data);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async get(storeName, key) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const request = store.get(key);
      request.onsuccess = () => resolve(request.result);
      request.onerror = () => reject(request.error);
    });
  }
  
  async getAll(storeName, query, count) {
    const transaction = this.db.transaction([storeName], 'readonly');
    const store = transaction.objectStore(storeName);
    
    return new Promise((resolve, reject) => {
      const results = [];
      const request = store.openCursor(query);
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor && (count ? results.length < count : true)) {
          results.push(cursor.value);
          cursor.continue();
        } else {
          resolve(results);
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }
  
  async clearOldData(storeName, maxAge = 7 * 24 * 60 * 60 * 1000) {
    const transaction = this.db.transaction([storeName], 'readwrite');
    const store = transaction.objectStore(storeName);
    const index = store.index('timestamp');
    const cutoff = Date.now() - maxAge;
    
    return new Promise((resolve, reject) => {
      const request = index.openCursor(IDBKeyRange.upperBound(cutoff));
      
      request.onsuccess = (event) => {
        const cursor = event.target.result;
        if (cursor) {
          cursor.delete();
          cursor.continue();
        } else {
          resolve();
        }
      };
      
      request.onerror = () => reject(request.error);
    });
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const productCache = new IndexedDBCache('shop-cache', 1);

// åˆå§‹åŒ–
await productCache.init([
  {
    name: 'products',
    keyPath: 'id',
    indexes: [
      { name: 'timestamp', keyPath: 'updatedAt' },
      { name: 'category', keyPath: 'categoryId' }
    ]
  },
  {
    name: 'cart',
    keyPath: 'itemId'
  }
]);

// ç¼“å­˜äº§å“æ•°æ®
async function cacheProducts(products) {
  for (const product of products) {
    await productCache.add('products', {
      ...product,
      updatedAt: Date.now(),
      cachedAt: Date.now()
    });
  }
}

// è¯»å–ç¼“å­˜
async function getCachedProducts(categoryId) {
  return await productCache.getAll('products', 
    IDBKeyRange.only(categoryId)
  );
}
```

## ğŸ“Š **æ€§èƒ½ç›‘æ§å…·ä½“å®ç°**

### 1. **è‡ªå®šä¹‰æ€§èƒ½ç›‘æ§**
```javascript
class PerformanceMonitor {
  constructor() {
    this.metrics = new Map();
    this.reportUrl = '/api/performance';
  }
  
  startMeasure(name) {
    if (performance.mark) {
      performance.mark(`start-${name}`);
    }
    
    this.metrics.set(name, {
      startTime: performance.now(),
      startDate: new Date()
    });
  }
  
  endMeasure(name, customData = {}) {
    const metric = this.metrics.get(name);
    if (!metric) return;
    
    const endTime = performance.now();
    const duration = endTime - metric.startTime;
    
    if (performance.mark && performance.measure) {
      performance.mark(`end-${name}`);
      performance.measure(name, `start-${name}`, `end-${name}`);
    }
    
    // æ”¶é›†æŒ‡æ ‡
    const data = {
      name,
      duration,
      timestamp: metric.startDate.toISOString(),
      ...customData,
      // é¡µé¢ä¿¡æ¯
      url: window.location.href,
      userAgent: navigator.userAgent,
      connection: navigator.connection ? {
        effectiveType: navigator.connection.effectiveType,
        downlink: navigator.connection.downlink
      } : null
    };
    
    // å‘é€åˆ°æœåŠ¡å™¨
    this.sendMetric(data);
    
    // æ¸…ç†
    this.metrics.delete(name);
  }
  
  sendMetric(data) {
    // ä½¿ç”¨ sendBeacon æˆ– fetch
    if (navigator.sendBeacon) {
      const blob = new Blob([JSON.stringify(data)], { type: 'application/json' });
      navigator.sendBeacon(this.reportUrl, blob);
    } else {
      fetch(this.reportUrl, {
        method: 'POST',
        body: JSON.stringify(data),
        keepalive: true
      });
    }
  }
  
  // ç›‘æ§æ ¸å¿ƒ Web Vitals
  monitorCoreWebVitals() {
    // LCP ç›‘æ§
    const po = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      const lastEntry = entries[entries.length - 1];
      
      this.sendMetric({
        type: 'LCP',
        value: lastEntry.startTime,
        element: lastEntry.element?.tagName
      });
    });
    
    po.observe({ type: 'largest-contentful-paint', buffered: true });
    
    // FID ç›‘æ§
    const fidObserver = new PerformanceObserver((entryList) => {
      const entries = entryList.getEntries();
      entries.forEach(entry => {
        this.sendMetric({
          type: 'FID',
          value: entry.processingStart - entry.startTime,
          name: entry.name
        });
      });
    });
    
    fidObserver.observe({ type: 'first-input', buffered: true });
    
    // CLS ç›‘æ§
    let clsValue = 0;
    const clsObserver = new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        if (!entry.hadRecentInput) {
          clsValue += entry.value;
        }
      }
    });
    
    clsObserver.observe({ type: 'layout-shift', buffered: true });
    
    // å®šæœŸæŠ¥å‘Š CLS
    setInterval(() => {
      if (clsValue > 0) {
        this.sendMetric({
          type: 'CLS',
          value: clsValue
        });
      }
    }, 5000);
  }
  
  // ç›‘æ§é•¿ä»»åŠ¡
  monitorLongTasks() {
    const observer = new PerformanceObserver((list) => {
      for (const entry of list.getEntries()) {
        if (entry.duration > 50) { // è¶…è¿‡50msçš„ä»»åŠ¡
          this.sendMetric({
            type: 'LONG_TASK',
            duration: entry.duration,
            startTime: entry.startTime
          });
        }
      }
    });
    
    observer.observe({ entryTypes: ['longtask'] });
  }
}

// React æ€§èƒ½ç›‘æ§ç»„ä»¶
const withPerformanceMonitor = (Component, componentName) => {
  return function WrappedComponent(props) {
    const monitorRef = useRef(new PerformanceMonitor());
    
    useEffect(() => {
      monitorRef.current.startMeasure(`${componentName}_mount`);
      
      return () => {
        monitorRef.current.endMeasure(`${componentName}_mount`, {
          propsCount: Object.keys(props).length
        });
      };
    }, []);
    
    useEffect(() => {
      monitorRef.current.startMeasure(`${componentName}_render`);
      
      return () => {
        monitorRef.current.endMeasure(`${componentName}_render`);
      };
    });
    
    return <Component {...props} />;
  };
};
```

## ğŸš¨ **åº”æ€¥ä¼˜åŒ–æ–¹æ¡ˆ**

### 1. **æ€§èƒ½é™çº§ç­–ç•¥**
```javascript
class PerformanceDegradation {
  constructor() {
    this.isLowEndDevice = this.checkDevicePerformance();
    this.isSlowNetwork = this.checkNetworkSpeed();
  }
  
  checkDevicePerformance() {
    // æ£€æŸ¥è®¾å¤‡æ€§èƒ½
    const memory = navigator.deviceMemory || 4;
    const cores = navigator.hardwareConcurrency || 4;
    const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(
      navigator.userAgent
    );
    
    return memory < 4 || cores < 4 || isMobile;
  }
  
  checkNetworkSpeed() {
    if (navigator.connection) {
      return navigator.connection.effectiveType === 'slow-2g' || 
             navigator.connection.effectiveType === '2g' ||
             navigator.connection.downlink < 1;
    }
    return false;
  }
  
  applyOptimizations() {
    if (this.isLowEndDevice || this.isSlowNetwork) {
      // é™ä½åŠŸèƒ½å¤æ‚åº¦
      this.disableAnimations();
      this.reduceImageQuality();
      this.limitConcurrentRequests();
      this.enableBasicMode();
    }
  }
  
  disableAnimations() {
    document.documentElement.classList.add('reduced-motion');
    
    // CSS ä¼˜åŒ–
    const style = document.createElement('style');
    style.textContent = `
      .reduced-motion * {
        animation-duration: 0.01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: 0.01ms !important;
      }
    `;
    document.head.appendChild(style);
  }
  
  reduceImageQuality() {
    // å…¨å±€å›¾ç‰‡è´¨é‡é™ä½
    const images = document.querySelectorAll('img');
    images.forEach(img => {
      const src = img.src;
      if (src.includes('upload/resize=')) {
        img.src = src.replace(/resize=\d+/, 'resize=800');
      } else {
        img.loading = 'lazy';
      }
    });
  }
  
  limitConcurrentRequests() {
    // è¯·æ±‚é˜Ÿåˆ—ç®¡ç†
    const maxConcurrent = 2;
    let activeRequests = 0;
    const requestQueue = [];
    
    const originalFetch = window.fetch;
    window.fetch = function(...args) {
      return new Promise((resolve, reject) => {
        const request = () => {
          activeRequests++;
          originalFetch.apply(this, args)
            .then(resolve)
            .catch(reject)
            .finally(() => {
              activeRequests--;
              if (requestQueue.length > 0) {
                requestQueue.shift()();
              }
            });
        };
        
        if (activeRequests < maxConcurrent) {
          request();
        } else {
          requestQueue.push(request);
        }
      });
    };
  }
  
  enableBasicMode() {
    // åˆ‡æ¢åˆ°åŸºç¡€ç‰ˆæœ¬
    localStorage.setItem('basicMode', 'true');
    document.documentElement.classList.add('basic-mode');
    
    // ç§»é™¤éå¿…è¦åŠŸèƒ½
    const heavyComponents = document.querySelectorAll('[data-heavy]');
    heavyComponents.forEach(comp => {
      const placeholder = document.createElement('div');
      placeholder.className = 'basic-placeholder';
      placeholder.textContent = 'å†…å®¹åŠ è½½ä¸­...';
      comp.replaceWith(placeholder);
    });
  }
}
```

### 2. **å…³é”®æ¸²æŸ“è·¯å¾„ä¼˜åŒ–**
```javascript
// å…³é”®CSSå†…è”
function inlineCriticalCSS() {
  const criticalCSS = `
    /* é¦–å±å…³é”®æ ·å¼ */
    body { margin: 0; font-family: system-ui; }
    .header, .hero, .primary-content { 
      opacity: 1; 
      transform: none; 
    }
  `;
  
  const style = document.createElement('style');
  style.textContent = criticalCSS;
  document.head.appendChild(style);
  
  // å¼‚æ­¥åŠ è½½éå…³é”®CSS
  const link = document.createElement('link');
  link.rel = 'stylesheet';
  link.href = '/styles.css';
  link.media = 'print';
  link.onload = () => {
    link.media = 'all';
  };
  document.head.appendChild(link);
}

// å…³é”®JSå»¶è¿Ÿæ‰§è¡Œ
function deferNonCriticalJS() {
  const scripts = document.querySelectorAll('script[data-defer]');
  scripts.forEach(script => {
    const newScript = document.createElement('script');
    newScript.src = script.src;
    newScript.async = true;
    script.replaceWith(newScript);
  });
  
  // ä½¿ç”¨ requestIdleCallback æ‰§è¡Œä½ä¼˜å…ˆçº§ä»»åŠ¡
  if ('requestIdleCallback' in window) {
    window.requestIdleCallback(() => {
      // åŠ è½½ç¬¬ä¸‰æ–¹ç»„ä»¶
      loadThirdPartyComponents();
      // åˆå§‹åŒ–éå¿…è¦åŠŸèƒ½
      initializeNonCriticalFeatures();
    });
  }
}
```

è¿™äº›å…·ä½“æ–¹æ¡ˆå¯ä»¥ç›´æ¥åº”ç”¨åˆ°é¡¹ç›®ä¸­ï¼Œæ ¹æ®å®é™…æƒ…å†µè¿›è¡Œè°ƒæ•´ã€‚å…³é”®æ˜¯è¦å»ºç«‹æ€§èƒ½ç›‘æ§ä½“ç³»ï¼ŒæŒç»­æµ‹é‡å’Œä¼˜åŒ–ã€‚