// 4.子数组的和： 原题为 String s= "2+3*4-4/2+1";  算出结果(力扣上没有类似的题目)  ；候选人强调这种是放水题目，比较简单，但在线写编程不太好写，说思路就可以过

// 这类包含 +、-、*、/ 的四则运算，核心是利用栈处理运算符优先级（先乘除后加减），整体分为 3 步：
// 预处理与遍历：遍历表达式字符串，提取数字（处理多位数）和运算符；
// 栈处理乘除：遇到 +、- 时，将数字（带符号）压入栈；遇到 *、/ 时，弹出栈顶数字与当前数字计算，结果再压栈；
// 栈求和：遍历结束后，栈内所有数字求和即为最终结果。
// 思路本质：把乘除运算 “就地计算”，把加减运算 “延迟到最后求和”，通过栈简化优先级处理。

// /**
//  * 计算包含 +-*/ 的四则运算表达式（无括号、正整数）
//  * @param {string} s - 算术表达式字符串（如 "2+3*4-4/2+1"）
//  * @returns {number} 计算结果
//  */
function calculate(s) {
  const stack = []; // 存储待加减的数字（带符号）
  let num = 0; // 临时存储当前解析的数字
  let op = "+"; // 记录上一个运算符（初始为+，处理第一个数字）

  // 遍历每个字符（最后补一个+，确保最后一个数字入栈）
  for (let i = 0; i <= s.length; i++) {
    const char = s[i];

    // 1. 解析数字（处理多位数，如 "123"）
    if (char >= "0" && char <= "9") {
      num = num * 10 + (char - "0");
      continue;
    }

    // 2. 遇到运算符/遍历结束，处理上一个运算符和当前数字
    switch (op) {
      case "+":
        stack.push(num); // 加：直接压入正数
        break;
      case "-":
        stack.push(-num); // 减：压入负数
        break;
      case "*":
        // 乘：弹出栈顶 * 当前数字，结果压栈
        stack.push(stack.pop() * num);
        break;
      case "/":
        // 除：弹出栈顶 / 当前数字，保留整数（向下取整，同数学规则）
        stack.push(Math.trunc(stack.pop() / num));
        break;
    }

    // 3. 更新运算符，重置当前数字
    op = char;
    num = 0;
  }

  // 4. 栈内所有数字求和（加减运算）
  return stack.reduce((sum, curr) => sum + curr, 0);
}

// 测试用例
const s = "2+3*4-4/2+1";
console.log(`表达式：${s}`);
console.log(`计算结果：${calculate(s)}`); // 输出 13（2+12-2+1=13）

// 扩展测试：验证多位数和除法
console.log(calculate("10+20*3-15/5")); // 10+60-3=67
console.log(calculate("8/2*3-4")); // 12-4=8
